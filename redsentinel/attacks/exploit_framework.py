# redsentinel/attacks/exploit_framework.py
from redsentinel.tools.external_tool import find_binary, run_command
import logging

logger = logging.getLogger(__name__)


def searchsploit_search(service, version=None):
    """
    Search ExploitDB for exploits
    
    Args:
        service: Service name (e.g., "apache", "mysql")
        version: Optional version
    
    Returns:
        dict with exploit results
    """
    binpath = find_binary("searchsploit")
    if not binpath:
        return {"error": "searchsploit not found. Install with: sudo apt install exploitdb"}
    
    cmd = f"{binpath} {service}"
    if version:
        cmd += f" {version}"
    
    cmd += " --colour"  # Colored output
    
    rc, out, err = run_command(cmd, timeout=60, dry_run=False)
    
    return {"rc": rc, "out": out, "err": err}


def msf_module_search(module_type, target=None):
    """
    Search Metasploit modules
    
    Args:
        module_type: Type (exploit, auxiliary, payload, etc.)
        target: Optional target keyword
    
    Returns:
        dict with module results
    """
    binpath = find_binary("msfconsole")
    if not binpath:
        return {"error": "Metasploit not found. Install: sudo apt install metasploit-framework"}
    
    # Use msfcli or msfsearch if available
    search_cmd = find_binary("msfsearch")
    if search_cmd:
        if target:
            cmd = f"{search_cmd} {target} type:{module_type}"
        else:
            cmd = f"{search_cmd} type:{module_type}"
        
        rc, out, err = run_command(cmd, timeout=60, dry_run=False)
        return {"rc": rc, "out": out, "err": err}
    
    return {"error": "msfsearch not available. Use Metasploit framework directly"}


def cve_to_exploit(cve_number):
    """
    Find exploits for a specific CVE
    
    Args:
        cve_number: CVE identifier (e.g., "CVE-2021-44228")
    
    Returns:
        dict with exploit information
    """
    results = {
        "cve": cve_number,
        "searchsploit": None,
        "suggested_modules": []
    }
    
    # Search in ExploitDB
    search_result = searchsploit_search(cve_number)
    results["searchsploit"] = search_result
    
    # Try to extract useful information
    if search_result.get("out"):
        # Parse for exploit paths or URLs
        output = search_result["out"]
        if "Exploits:" in output:
            results["suggested_modules"] = ["Check searchsploit output for paths"]
    
    return results


def suggest_msf_modules(service_info):
    """
    Suggest Metasploit modules based on service information
    
    Args:
        service_info: Dict with service details (name, version, port)
    
    Returns:
        dict with suggested modules
    """
    suggestions = {
        "service": service_info,
        "modules": []
    }
    
    service_name = service_info.get("name", "").lower()
    version = service_info.get("version", "").lower()
    
    # Basic suggestions based on common services
    if "apache" in service_name:
        suggestions["modules"].append({
            "name": "auxiliary/scanner/http/apache_mod_cgi_bash_env",
            "type": "auxiliary",
            "description": "Check for Shellshock vulnerability"
        })
    
    if "mysql" in service_name or "mariadb" in service_name:
        suggestions["modules"].append({
            "name": "auxiliary/admin/mysql/mysql_sql",
            "type": "auxiliary",
            "description": "MySQL SQL execution"
        })
        suggestions["modules"].append({
            "name": "auxiliary/scanner/mysql/mysql_login",
            "type": "auxiliary",
            "description": "MySQL login brute force"
        })
    
    if "ftp" in service_name:
        suggestions["modules"].append({
            "name": "auxiliary/scanner/ftp/ftp_login",
            "type": "auxiliary",
            "description": "FTP login brute force"
        })
        if "vsftpd" in version and "2.3.4" in version:
            suggestions["modules"].append({
                "name": "exploit/unix/ftp/vsftpd_234_backdoor",
                "type": "exploit",
                "description": "VSFTPD v2.3.4 backdoor"
            })
    
    if "ssh" in service_name:
        suggestions["modules"].append({
            "name": "auxiliary/scanner/ssh/ssh_login",
            "type": "auxiliary",
            "description": "SSH login brute force"
        })
    
    if "smb" in service_name or "samba" in service_name:
        suggestions["modules"].append({
            "name": "auxiliary/scanner/smb/smb_login",
            "type": "auxiliary",
            "description": "SMB login brute force"
        })
        if "3" in version:
            suggestions["modules"].append({
                "name": "exploit/linux/samba/is_known_pipename",
                "type": "exploit",
                "description": "Samba is_known_pipename RCE"
            })
    
    if "http" in service_name:
        suggestions["modules"].append({
            "name": "auxiliary/scanner/http/http_version",
            "type": "auxiliary",
            "description": "HTTP version detection"
        })
    
    return suggestions


def comprehensive_exploit_search(target, port, service, version=None):
    """
    Comprehensive exploit search
    
    Args:
        target: Target host
        port: Port number
        service: Service name
        version: Service version
    
    Returns:
        dict with all exploit results
    """
    results = {
        "target": target,
        "port": port,
        "service": service,
        "version": version,
        "exploits": {},
        "msf_suggestions": {}
    }
    
    # Search ExploitDB
    if service:
        searchsploit_res = searchsploit_search(service, version)
        results["exploits"]["searchsploit"] = searchsploit_res
    
    # Get MSF suggestions
    service_info = {
        "name": service,
        "version": version,
        "port": port
    }
    msf_suggestions = suggest_msf_modules(service_info)
    results["msf_suggestions"] = msf_suggestions
    
    return results


def parse_searchsploit_output(output):
    """Parse searchsploit output"""
    results = {
        "exploits": [],
        "shellcodes": [],
        "papers": [],
        "total": 0
    }
    
    lines = output.split("\n")
    for line in lines:
        if "|" in line and "ExploitDB ID" not in line:
            parts = line.split("|")
            if len(parts) >= 3:
                path = parts[0].strip()
                title = parts[1].strip()
                platform = parts[2].strip() if len(parts) > 2 else ""
                
                result_item = {
                    "path": path,
                    "title": title,
                    "platform": platform
                }
                
                if "exploit" in path.lower():
                    results["exploits"].append(result_item)
                elif "shellcode" in path.lower():
                    results["shellcodes"].append(result_item)
                elif "paper" in path.lower():
                    results["papers"].append(result_item)
    
    results["total"] = len(results["exploits"]) + len(results["shellcodes"]) + len(results["papers"])
    
    return results

